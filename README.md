# Secrets-Cipher-Base64 

[![Gem Version](https://badge.fury.io/rb/secrets-cipher-base64.svg)](https://badge.fury.io/rb/secrets-cipher-base64)
[![Downloads](http://ruby-gem-downloads-badge.herokuapp.com/secrets-cipher-base64?type=total)](https://rubygems.org/gems/secrets-cipher-base64)

<br />

[![Build Status](https://travis-ci.org/kigster/secrets-cipher-base64.svg?branch=master)](https://travis-ci.org/kigster/secrets-cipher-base64)
[![Code Climate](https://codeclimate.com/github/kigster/secrets-cipher-base64/badges/gpa.svg)](https://codeclimate.com/github/kigster/secrets-cipher-base64)
[![Test Coverage](https://codeclimate.com/github/kigster/secrets-cipher-base64/badges/coverage.svg)](https://codeclimate.com/github/kigster/secrets-cipher-base64/coverage)
[![Issue Count](https://codeclimate.com/github/kigster/secrets-cipher-base64/badges/issue_count.svg)](https://codeclimate.com/github/kigster/secrets-cipher-base64)

## Summary

This gem provides an easy way to store application secrets as base64-encoded strings (ie, in YAML or JSON) and be able to quickly decrypt them when they are read, or encrypt them when they are written.

The library simply organizes the code in the discussion here: http://stuff-things.net/2015/02/12/symmetric-encryption-with-ruby-and-rails/ and makes it really easy to use.

## Symmetric Encryption/Decryption

This simply means we are using the same key to encrypt/decrypt. The secret that's generated by the tool is a base64-encoded string and is 45 characters long. The decoded secret is always 32 characters long (or 256 bytes long).

Second aspect of the encryption is the IV vector. The library completely hides `iv` from the user, generates one random `iv` per encrypted field, and stores it together with the field itself.

## Installation

Add this line to your application's Gemfile:

```ruby
gem 'secrets-cipher-base64'
```

And then execute:

    $ bundle

Or install it with `gem` command:

    $ gem install secrets-cipher-base64

## Usage

### Secret Explained 

The library relies on a secret that must be stored somewhere safely on your local system, for example it can be in the keychain on Mac OSX.

You can use one key for all encrypted fields, or many keys – perhaps one per deployment environment, etc. While you can have per-field secrets, it seems like an overkill.

__NOTE: never check in the secret into git.__

We'll show how to generate a secret down below.

### Storing the Secret

How you store the secret, is up to you, but here is one way that leverages Mac OS-X Keychain to store the key. In fact you can store multiple keys if you like. In the example below we'll store two seperate secrets, one for staging and one for production:

In your terminal, type these two commands. Note that the `-s` parameter is something you might want to customize, and make it easy to find. For example, instead of using `production` you could use `big-corp-django-secret-production`. The name should be such that it's easy to find once you open KeyChain Editor later.

```bash
security add-generic-password -a $USER -D "secret-cipher-base64" -s "staging"
security add-generic-password -a $USER -D "secret-cipher-base64" -s "production"
```

This step does not actually store any key, it simply creates a KeyChain placeholder for it. We'll generate and add the key next.

Finally, to make this a bit more efficient, I recommend listing the key names in an array-type environment variable set in your `~/.bashrc` file, for example:

```bash
# ~/.bashrc
declare -a secret_names=(production staging)
```

After declaring this array, you can even rewrite the above command as a loop, which could be handy if you are storing not 2 or 3 but 10+ keys.

```bash
for secret_name in ${secret_names[@]}; do
  security add-generic-password -a $USER \ 
      -D "secret-cipher-base64" -s $secret_name
done
```

### Generating Secrets
 
Generating secret is easy with this library. 

You can do so programmatically, or using the command line.

In ruby you would do the following:

```ruby
require 'secrets/cipher/base64'
@secret = Secrets.create_secret
```

Once the gem is installed you will be able to run an executable `secrets`:

```bash
secrets -g | pbcopy
```

(if you installed the gem with bundler, make sure to prefix the above command with `bundle exec`).

With the key in your clipboard, let's save it to the KeyChain:
 
### Saving the Secret to KeyChain

* Open `KeyChain Access` application 
* Search for the token you specified, for example `production`
* Double-click on the matching entry
* Click "Show password"
* Paste the copied value in that field
* Click "Save Changes"
* Repeat for `staging` or any other key you want to save.

### Retrieving Secret from the KeyChain

Using the below bash function, you can retrieve and export the secrets as environment variables, which can later be read by your code:

```bash
# append this function to your ~/.bashrc or ~/.bash_profile
function load_secrets() {
  declare -a secret_names=(production staging)
  for secret_name in ${secret_names[@]}; do
    varname="secret_${secret_name}"  # eg, $secret_production 
    secret=`security find-generic-password -g -a $USER -w -D "secret-cipher-base64" -s "$secret_name"`
    eval "export $varname=$secret"
  done
}  
```

With this out of the way, we just need to type `load_secrets` in Terminal to get our keys automatically exported.

### Encrypting & Decrypting Data in Ruby

So how would we use this library from another ruby project to encrypt and decrypt values?

There are several ways to incorporate this library in your code. You will choose the most appropriate method based on whether you need to encrypt data types other than a string.

If the answer is "no" – ie. you only need to encrypt strings, then you will be well served by the simple instance methods `#encr` and `#decr` which encrypt and decrypt a string value using a provided secret. We show this in the method #1 below.

If you need to encrypt other data types, such as `Integer`, `Symbol`, or a `Hash`, you should be using `Secrets::Encrypted::ScalarData` class – or the below mentioned Facåde in the method #2.

#### 1. Encrypting/Decrypting Strings

After including `Secrets` module, your class will now have the `#encr` and `#decr` instance methods, as well as `#secret` and `#create_secret` class methods.

Therefore you could write something like this below, protecting a sensitive string using a class-level secret.

```ruby
require 'secrets'
class TestClass
  include Secrets
  secret ENV['SECRET']
  
  def sensitive_value=(value)
    @sensitive_value = encr(value, self.class.secret)
  end
  def sensitive_value
    decr(@sensitive_value, self.class.secret)
  end
end
```

#### 2. Encrypting Scalar Data Types

To encrypt scalar data types, you could be using the following facåde API:

```ruby
encrypted = Secrets::Encrypt.scalar(3.1415926, Secrets.secret)
decrypted = Secrets::Decrypt.scalar(encrypted, Secrets.secret)
```

Note that we are using randomly generated `secret`, which is saved on the `Secrets` module for the duration of the ruby session. If you are persisting the data make sure to save the auto-generated secret in a secure place.


#### 3. Encrypting Complex Data Types, such as a `Hash`

This is how you would encrypt __all values__ in a hash. Note that the below API does NOT encrypt keys.

```ruby
encrypted = Secrets::Encrypt.hash({'name' => :unknown}, Secrets.secret)
decrypted = Secrets::Decrypt.hash(encrypted_hash, Secrets.secret)
```

__Adding Custom Data Types:__

If your hash contains values that are of data type other than the basic supported scalar types, or a string, you can write your own simple decoder that is able to convert a `#to_s` representation of your object into a new object of the same type.

You would the use the following API to do so:

```ruby
Secrets.add_scalar_type id: 'x', type: XtraCool, string_to_type_proc: ->(string) { XtraCool.new(string) }
```

The above code allows `Secrets` library to encrypt hash values of the type `XtraCool`, by first calling `#to_s` on t
 


# Encrypting and Decrypting Hashes (and YAML)

A ruby class `Secrets::EncryptedHash` is offered so that you can encrypt values in a hash, and later decrypt them.

Here is a simple way to encrypt and decrypt a hash in ruby:

```ruby
    hash = {
        'name'     => { 'first'         => 'Bill', 
                        'last'          => 'Clinton' },                        
        'address'  => { 'street1'       => '1 Market Street, Apt 000',
                        'street2'       => nil,
                        'city'          => 'San Francisco',
                        'state'         => 'CA',
                        'zip'           => 94107,
                        'home_address?' => true },                       
        'password' => "goddamnhrc"
      }
    }
    hash_encrypted    = Secrets::Encrypted::HashData.new(hash).encrypt(secret)
    hash_decrypted    = hash_encrypted.decrypt(secret)

    yaml_encrypted    = hash_encrypted.to_hash.to_yaml
    yaml_decrypted    = hash_decrypted.to_hash.to_yaml
```

### Command Line Tool

The library installs a command line tool that can be used to encrypt/decrypt data or to generate a new secret.

Here is the full help message for the `secrets` tool:

```bash
Usage: 
    secrets [options]

Options:
    -V, --version            print the version
    -p, --phrase    [string] specify a string to encrypt/decrypt
    -y, --yaml      [file]   yaml file to encr/decr; use "-" for STDIN/OUT
    
Modes:
    -e, --encrypt            encrypt
    -d, --decrypt            decrypt
    -g, --generate           generate new secret
    -h, --help               show help
    
Flags:
    -v, --verbose            show additional info
    -s, --secret    [secret] specify a secret
```

#### CLI Examples

```bash
  # generate a new secret:
  > export SECRET=$(secrets -g)
  > echo $SECRET
  75ngenJpB6zL47/8Wo7Ne6JN1pnOsqNEcIqblItpfg4=

  # encrypt a plain text string with the secret:
  > export ENCRYPTED=$(secrets -e -p "secret string" -s $SECRET)
  > echo $ENCRYPTED
  Y09MNDUyczU1S0UvelgrLzV0RTYxZz09CkBDMEw4Q0R0TmpnTm9md1QwNUNy%T013PT0K%

  # decrypt a previously encrypted phrase:
  > secrets -d -p $ENCRYPTED -s $SECRET
  secret string
  
  # encrypt a YAML file:
  secret -e -s $SECRET -y secrets.yaml > encrypted-secrets.yml
  secret -d -s $SECRET -y encrypted-secrets.yml > decrypted-secrets.yml
```

## Development

After checking out the repo, run `bin/setup` to install dependencies. Then, run `rake spec` to run the tests. You can also run `bin/console` for an interactive prompt that will allow you to experiment.

To install this gem onto your local machine, run `bundle exec rake install`. To release a new version, update the version number in `version.rb`, and then run `bundle exec rake release`, which will create a git tag for the version, push git commits and tags, and push the `.gem` file to [rubygems.org](https://rubygems.org).

## Contributing

Bug reports and pull requests are welcome on GitHub at https://github.com/kigster/secrets-cipher-base64.

## License

The gem is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).

## Author

This library is the work of [Konstantin Gredeskoul](http:/kig.re), &copy; 2016, distributed under the MIT license.

