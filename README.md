# Secrets-Cipher-Base64 

[![Gem Version](https://badge.fury.io/rb/secrets-cipher-base64.svg)](https://badge.fury.io/rb/secrets-cipher-base64)
[![Downloads](http://ruby-gem-downloads-badge.herokuapp.com/secrets-cipher-base64?type=total)](https://rubygems.org/gems/secrets-cipher-base64)

<br />

[![Build Status](https://travis-ci.org/kigster/secrets-cipher-base64.svg?branch=master)](https://travis-ci.org/kigster/secrets-cipher-base64)
[![Code Climate](https://codeclimate.com/github/kigster/secrets-cipher-base64/badges/gpa.svg)](https://codeclimate.com/github/kigster/secrets-cipher-base64)
[![Test Coverage](https://codeclimate.com/github/kigster/secrets-cipher-base64/badges/coverage.svg)](https://codeclimate.com/github/kigster/secrets-cipher-base64/coverage)
[![Issue Count](https://codeclimate.com/github/kigster/secrets-cipher-base64/badges/issue_count.svg)](https://codeclimate.com/github/kigster/secrets-cipher-base64)

## Summary

This gem provides an easy way to store application secrets as `AES-256-cbc`-encrypted, base64-encoded strings (ie, compatible with storing them in YAML or JSON). The library allows quickly encrypting and decryption of the sensitive data using a single (hence "symmetric") 256-bit private key.

> NOTE: The library leverages the code shown in the following discussion: http://stuff-things.net/2015/02/12/symmetric-encryption-with-ruby-and-rails/ Thanks to the author of the above thread for demonstrating it.

## Symmetric Encryption

Symmetric encryption simply means that we are using the same private key to encrypt and decrypt. The secret can be generated by the tool and is a *base64-encoded* string which is 45 characters long. The *base64-decoded* secret is always 32 characters long (or 256 bytes long).

In addition to the private key, the encryption uses an IV vector. The library completely hides `iv` from the user, generates one random `iv` per encryption, and stores it together with the field itself (*base64-encoded*).

## Installation

If you plan on using the library in your ruby project, which utilizes Bundler to manage dependencies, then include the following line in your `Gemfile`:

```ruby
gem 'secrets-cipher-base64'
```
And then execute: `bundle`.

Or install it with `gem install` command:

    $ gem install secrets-cipher-base64
    $ secrets -h

## Usage

### Private Keys (aka "Secrets")

This library relies on the existance of the private key (aka, *a secret*), that must be stored somewhere safely if your encrypted data is to be persisted, for example it can be saved into the keychain on Mac OSX. 

We demonstrate how to use Mac OS-X Keychain Access application to manage your keys further down in this README.

You can use one key for all encrypted fields, or many keys â€“ perhaps one per deployment environment, etc. While you can have per-field secrets, it seems like an overkill.

__NOTE: it is considered a very bad practice to check in the secret into version control.__  If you keep your secret out of your repo, you can then actially check-in encrypted secrets directly into the repo. As long as the secret itself is safe, the data in your encrypted secrets will be next to impossible to extract. 

### Generating Private Keys
 
Generating a private is very easy with this library. 

You can do so using the command line, or in a programmatic way. 

#### 1. Command Line

Once the gem is installed you will be able to run an executable `secrets`:

```bash
gem install secrets-cipher-base64
# then let's generate and copy the secret to Mac clipboard
secrets -g | pbcopy
# or save a new key into a bash variable
SECRET=$(secrets -g)
```

NOTE: If you installed the gem with bundler, make sure to prefix the above commands with `bundle exec`).

#### 2. Ruby

Upon including the `Secrets` module, each ruby class will receive it's own method `#key` and `#create_private_key`. The latter will generate a new key each time it's called, the former will either assign a key, or generate and save it in the class instance variable. Therefore each class including `Secrets` will use it's own key (unless the key is assigned).

```ruby
require 'secrets'
@secret = Secrets.create_private_key # generates a new key every time it's called
# OR
@secret = Secrets.private_key        # generates a new key and saves it
@secret.eql?(Secrets.private_key)    # => true

class TestClass
  include Secrets
end

@secret.eql?(TestClass.private_key)  # => false (a new key is saved in the class)

class SomeClass
  include Secrets
  secret Secrets.private_key
end

@secret.eql?(SomeClass.private_key)  # => true (it was assigned)
```
### Encrypting and Decrypting Data

As before, we'll first show how to encrypt raw data or files using the tool, and then show how to do the same in Ruby.

#### 1. CLI

This may be a good time to show the full help message for the `secrets` tool:

```bash
Usage: 
    secrets [options]

Options:
    -V, --version            print the version
    -p, --phrase    [string] specify a string to encrypt/decrypt
    -y, --yaml      [file]   yaml file to encr/decr; use "-" for STDIN/OUT
    
Modes:
    -e, --encrypt            encrypt
    -d, --decrypt            decrypt
    -g, --generate           generate new secret
    -h, --help               show help
    
Flags:
    -v, --verbose            show additional info
    -s, --secret    [key] specify a secret
```

##### CLI Examples

```bash
  # generate a new secret:
  > export SECRET_KEY=$(secrets -g)
  > echo $SECRET_KEY
  75ngenJpB6zL47/8Wo7Ne6JN1pnOsqNEcIqblItpfg4=

  # encrypt a plain text string with the secret:
  > export ENCRYPTED=$(secrets -e -p "secret string" -k $SECRET_KEY)
  > echo $ENCRYPTED
  Y09MNDUyczU1S0UvelgrLzV0RTYxZz09CkBDMEw4Q0R0TmpnTm9md1QwNUNy%T013PT0K%

  # decrypt a previously encrypted phrase:
  > secrets -d -p $ENCRYPTED -k $SECRET_KEY
  secret string
  
  # encrypt a YAML file:
  secret -e -k $SECRET_KEY -f secrets.yaml -o secrets.yml.enc
  secret -d -k $SECRET_KEY -f secrets.yml.enc -o secrets-decrypted.yml
```

#### 2. Ruby

So how would we use this library from another ruby project to encrypt and decrypt values?

After including the `Secrets` module in a ruby class, the class will now have the `#encr` and `#decr` instance methods, as well as `#secret` and `#create_private_key class methods.

Therefore you could write something like this below, protecting a sensitive string using a class-level secret.

```ruby
require 'secrets'
class TestClass
  include Secrets
  key ENV['SECRET']
  
  def sensitive_value=(value)
    @sensitive_value = encr(value, self.class.private_key)
  end
  def sensitive_value
    decr(@sensitive_value, self.class.private_key)
  end
end
```

## Store Secrets using Mac OS-X KeyChain Access and BASH 

How you store the secret, is up to you, but here is one way that leverages Mac OS-X Keychain. In fact you can store multiple keys if you like. In the example below we'll store two separate keys, one for staging and one for production:

In your terminal, type these two commands. Note that the `-s` parameter is something you might want to customize, and make it easy to find. For example, instead of using `production` you could use `big-corp-django-secret-production`. The name should be such that it's easy to find once you open KeyChain Editor later.

```bash
security add-generic-password -a $USER -D "secret-cipher-base64" -s "staging"
security add-generic-password -a $USER -D "secret-cipher-base64" -s "production"
```

This step does not actually store any key, it simply creates a KeyChain placeholder for it. We'll generate and add the key next.

Finally, to make this a bit more efficient, I recommend listing the key names in an array-type environment variable set in your `~/.bashrc` file, for example:

```bash
# ~/.bashrc
declare -a secret_names=(production staging)
```

After declaring this array, you can even rewrite the above command as a loop, which could be handy if you are storing not 2 or 3 but 10+ keys.

```bash
for secret_name in ${secret_names[@]}; do
  security add-generic-password -a $USER \ 
      -D "secret-cipher-base64" -s $secret_name
done
```
 
### Saving the Secret to KeyChain

* Open `KeyChain Access` application 
* Search for the token you specified, for example `production`
* Double-click on the matching entry
* Click "Show password"
* Paste the copied value in that field
* Click "Save Changes"
* Repeat for `staging` or any other key you want to save.

### Retrieving Secret from the KeyChain

Using the below bash function, you can retrieve and export the secrets as environment variables, which can later be read by your code:

```bash
# append this function to your ~/.bashrc or ~/.bash_profile
function load_keys() {
  declare -a secret_names=(production staging)
  for secret_name in ${secret_names[@]}; do
    varname="secret_${secret_name}"  # eg, $secret_production 
    secret=`security find-generic-password -g -a $USER -w -D "secret-cipher-base64" -s "$secret_name"`
    eval "export $varname=$secret"
  done
}  
```

With this out of the way, we just need to type `load_keys` in Terminal to get our keys automatically exported.

## Development

After checking out the repo, run `bin/setup` to install dependencies. Then, run `rake spec` to run the tests. You can also run `bin/console` for an interactive prompt that will allow you to experiment.

To install this gem onto your local machine, run `bundle exec rake install`. To release a new version, update the version number in `version.rb`, and then run `bundle exec rake release`, which will create a git tag for the version, push git commits and tags, and push the `.gem` file to [rubygems.org](https://rubygems.org).

## Contributing

Bug reports and pull requests are welcome on GitHub at https://github.com/kigster/secrets-cipher-base64.

## License

The gem is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).

## Author

This library is the work of [Konstantin Gredeskoul](http:/kig.re), &copy; 2016, distributed under the MIT license.

